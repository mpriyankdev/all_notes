Keywords :
- Moores Law
- JIT Compiler
- AOT Compiler

Architecture of JVM : 
.java --> javac --> .class --> classloader[single entry point] --> method cache --> interpreter --> profiler --> emitter --> code cache --> interpreter

Read article : The free lunch is over.
Processor memory performance gap.

Modern processor architecture:

CPU Cores
L1 cache
L2 cache [may or may not be shared , depends on the architecture]
L3 cache [shared between cores]
Northbridge [data flows through them from cache to main memory]
Main memory

1byte : 48 transistors

Unix Memory Model:[Unix process]
Text --> Data --> Heap --> Stack

Each thread in Unix will have its own stack frame and it will share access to the heap.

application thread and os thread are the same in java.

Unix process memory model : 
MMU : converts virtual addresses to the underlying physical address.
TLAP : Translation look ahead buffer.

Context switch : 
-Heavy weight context switch : a thread from once process needs to access some other thread from other process.Full reload needs to happen in the MMU.

------------------
JVM Memory and pointers:
-All JVM references are typed.
-Bytecode cannot call an arbitrary memory location.

Ordinary object pointer : lives inside the JVM.
-Every java reference[if it is not pointing to null] points to an oop location.

-Mark and Klass word.
-Every object in java has Object header and it is in the heap [every object in heap has to have the object header]
-Object pointer points from 1. Stack to heap 2. Heap to Heap.

Compresses OOPS : space saving mechanism.
32-bit JVM : 8bytes object header.
64-bit JVM : 16bytes object header.

To reduce this overhead per object , we have compressed oops.
Represesnt 64 bit address in 32bits.
Helps in saving the memory and address more objects in the heap.
-XX:+UseCompressedOops















